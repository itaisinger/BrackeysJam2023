///// combat system /////

the combat will be handled by a combat manager object.


/// combat turns loop ///

combat stages:
player chooses attack
gather attacks from the player and the enemy
play out attacks in order
end the combat if necessary

// player chooses attack
at the start of the loop, the combat manager calls the combat menu object and asks it to open the player menu.
the menu is a few clickable buttons, and when clicked they send the attack index to menu, 
which then sends the corresponding attack to the player object and tell the combat manager that the player chose an attack, and we can proceed to the next stage.

// getting turns
all combat participants have a get_action() method that asks them to send in an attack struct.
by now, the player has chosen an attack and it is saved inside a varieble, so when get_action() is called, it will return that attack.
both attack are stored inside a list. each attack's speed is calculated by fighter_speed + attack_speed_add, and are then properly sorted.

items can be also returned instead of attacks, but they are just the same. 
items are essentially attacks with 0 damage and an ability.

// playing out attacks
playing out attacks will work like so:
	- run the attack (subtract hp, run script)
	- send message to the ui element
	- wait for the player to press continue
	- loop back until we are out of attacks

// end the combat if necessary
check whether one of the sides is out of hp, and if so end the combat.
otherwise, loop back to "player chooses attack".


/// ability scripts ///
there is a list of ability scripts that is created inside of the combat manager, so that the scripts will be bound to it.
those scripts will usually use the varieble "fighter_self" and "fighter_enemy" to traget participants of the fight and affect them,
like applying some effect.

/// types ///
fighter doesnt have a spesific type, but a % of each type.
a fighter has an array of all the children fighters of it, and a method to update the array that hold the % of every type.
in order to manage it, a fighter also holds an array of all of its children fighters's types, 
and a function that updates it's types_arr by looping through the children's types.

fighters can also be assigned a standalone type variable, and that var is used when you merge them into another fighter.
all base creatures are created with base_fighter(), that takes a type and assigns it as its "type" variable.

in conclusion, type relevant variables:
type			int		holds enum value of a type. only base fighters have this var.
types_arr		array	has a value for each type in the game. values are 0-1, representing how much of this fighter is this type.
children_arr	array	holds a value for each children of this fighter, one for every time it has merged. each value is an enum from TYPES.

// type matchups
grid_type_matchups:	grid that stores matchups. the x represents the attacker and the y the attacked. the value is the % to be applied to the damage.
call get_type_damage(attack_type,fighter_type) to get the %.

structs classes:

fighter{
	name,
	sprite,
	hp,
	speed,
	types_arr,
	attacks_arr,
	items_arr,
}

attack{
	name,
	damage,
	speed_add,
	ability_script,
	
	accuracy,
	crit_chance
}

item{
	name,
	sprite_index,
	script,
}

// player object

methods:
get_action()		opens the turn choose menu

// enemy object
the enemy object has a fighter structs, and in it it fills his data.

methods:
init()			initializes the data into a fighter strcut.
get_action()		returns an attack from its attack array.





/////// UI ////////
obj_ui is the main ui object that handles all the front end visualisation.
it has a few methods that can be used by the back end to send info.

set_main_text(text)					prints a message in the main textbox
set_fighter_sprites(player,nme)		set the fighter sprites


// obj_player_menu
the player menu will consist of a few buttons:
side menu: attacks, items, action(?)
main menu: 4 big item buttons, containing the top menu's options.


// how to create player and enemy structs

global.player_struct = fighter("yossi",spr_hand,100,10,
					[attack("pow",5),attack("zues's thuder",20,ATT_SPEEDS.slow)],
					[item("messanger",0,function(){show_message("the messanger!")}),
					item("heal",1,function(){global.map_abilities[?"heal"](10)},0,-20)],
					bhvr_player);
					
global.nme_struct = fighter("bungalos",spr_zombie,100,7,
					[attack("feet",5),attack("fetus",1,ATT_SPEEDS.priority)],
					[],
					bhvr_scroll);
	
